<hr>
<h4>
             add
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            ADD reg, reg
</li>
<li>
            ADD reg, mem
</li>
<li>
            ADD reg, con
</li>
</ul>
<h5>Description</h5>

<p>
            Adds the first operand with the second and stores the result in
            the first operand. The destination can be a register or memory
            location; the source can be an immediate, register, or memory
            location. Two memory operands cannot be used. Immediate values are
            sign extended. Works on both signed and unsigned integer operands.
</p>
<hr>
<h4>
             sub
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            SUB reg, reg
</li>
<li>
            SUB reg, mem
</li>
<li>
            SUB reg, con
</li>
</ul>
<h5>Description</h5>

<p>
            Subtracts the second operand from the first operand and stores the
            result in the first operand. The destination can be a register or
            memory location; the source can be an immediate, register, or
            memory location. Two memory operands cannot be used. Immediate
            values are sign extended. Evaluates the result for both signed
            and unsigned integer operands.
</p>
<hr>
<h4>
             imul
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            IMUL reg, reg
</li>
<li>
            IMUL reg, mem
</li>
<li>
            IMUL reg, con
</li>
</ul>
<h5>Description</h5>

<p>
            Performs a signed multiplication of two operands. The first
            operand is multiplied by the second operand. The destination is a
            general purpose register and the source can be an immediate, a
            register, or a memory location. The product is truncated and
            stored in the destination operand location.
</p>
<hr>
<h4>
             and
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            AND reg, reg
</li>
<li>
            AND reg, mem
</li>
<li>
            AND reg, con
</li>
</ul>
<h5>Description</h5>

<p>
            Performs a bitwise AND operation on the destination (first) and
            source (second) operands and stores the result in the destination
            operand location. The source operand can be an immediate, a
            register, or a memory location; the destination operand can be a
            register or memory location. Two memory operands cannot be used in
            one instruction. Each bit of the result is set to 1 if both
            corresponding bits of the first and second operands are 1;
            otherwise it is set to 0.
</p>
<hr>
<h4>
             or
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            OR reg, reg
</li>
<li>
            OR reg, mem
</li>
<li>
            OR reg, con
</li>
</ul>
<h5>Description</h5>

<p>
            Performs a bitwise inclusive OR operation between the destination
            (first) and source (second) operands and stores the result in the
            destination operand location. The source operand can be an
            immediate, a register, or a memory location; the destination
            operand can be a register or a memory location. Two memory
            operands cannot be used in one instruction. Each bit of the result
            of the OR instruction is set to 0 if both corresponding bits of
            the first and second operands are 0; otherwise, each bit is set to
            1.
</p>
<hr>
<h4>
             xor
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            XOR reg, reg
</li>
<li>
            XOR reg, mem
</li>
<li>
            XOR reg, con
</li>
</ul>
<h5>Description</h5>

<p>
            Performs a bitwise exlcusive OR (XOR) operation on the destination
            (first) and source (second) operands and stores the result in the
            destination operand location. The source operand can be an
            immediate, a register, or a memory location; the destination
            operand can be a register or a memory location. Two memory
            operands cannot be used in one instruction. Each bit of the result
            is 1 if the corresponding bits of the operands are different; each
            bit is 0 if the corresponding bits are the same.
</p>
<hr>
<h4>
             shl
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            SHL reg, reg
</li>
<li>
            SHL reg, mem
</li>
<li>
            SHL reg, con
</li>
</ul>
<h5>Description</h5>

<p>
            Shifts the bits in the first operand (destination operand) to the
            left by the number of bits specified in the second operand
            (count operand). Bits shifted beyonf the destination operand
            boundary are first shifted into the CF flag, then discarded. At the
            end of the shift operation, the CF flag contains the last bit
            shifted out of the destination operand.
            The destination operand can be a register or a memory location. The
            count operand can be an immediate value or the CL register.
</p>
<hr>
<h4>
             shr
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            SHR reg, reg
</li>
<li>
            SHR reg, mem
</li>
<li>
            SHR reg, con
</li>
</ul>
<h5>Description</h5>

<p>
            Shifts the bits in the first operand (destination operand) to the
            right by the number of bits specified in the second operand
            (count operand). Bits shifted beyond the destination operand
            boundary are first shifted into the CF flag, then discarded. At the
            end of the shift operation, the CF flag contains the last bit
            shifted out of the destination operand.
            The destination operand can be a register or a memory location. The
            count operand can be an immediate value or a register.
</p>
<hr>
<h4>
             not
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            NOT reg
</li>
</ul>
<h5>Description</h5>

<p>
            Performs a bitwise NOT operation (each 1 is set to 0, and each 0 is
            set to 1) on the destination operand and stores the result in the
            destination operand location. The destination operand is a
            register.
</p>
<hr>
<h4>
             inc
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            INC reg
</li>
</ul>
<h5>Description</h5>

<p>
            Adds 1 to the destination operand, while preserving the state of
            the CF flag. The destination operand must be a register. This
            instruction allows a loop counter to be updated without disturbing
            the CF flag. (Use an ADD instriction with an immediate operand of 1
            to perform an increment operation that does update the CF flag.)
</p>
<hr>
<h4>
             dec
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            DEC reg
</li>
</ul>
<h5>Description</h5>

<p>
            Subtracts 1 from the destination operand, while preserving the
            state of the CF flag. The destination operand must be a register.
            This instruction allows a loop counter to be updated without
            disturbing the CF flag. (To perform a decrement operation that
            updates the CF flag, use a SUB instruction with an immediate
            operand of 1.)
</p>
<hr>
<h4>
             neg
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            NEG reg
</li>
</ul>
<h5>Description</h5>

<p>
           Replaces the value of operand (the destination operand) with its
           two's complement. (This operation is equivalent to subracting the
           operand from 0.) The destination operand is located in a general-
           purpose register.
</p>
<hr>
<h4>
             idiv
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            IDIV reg
</li>
</ul>
<h5>Description</h5>

<p>
            The idiv instruction divides the contents of the 64 bit integer
            EDX:EAX (constructed by viewing EDX as the most significant four
            bytes and EAX as the least significant four bytes) by the specified
            operand value. The quotient result of the division is stored into
            EAX, while the remainder is placed in EDX.
</p>
<hr>
<h4>
        btr
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
        btr reg, reg
</li>
<li>
        btr reg, const
</li>
</ul>
<h5>Description</h5>

<p>
        Selects the bit in a bit string (specified with the first operand,
        called the bit base) at the bit-position designated by the bit offset
        operand (second operand), stores the value of the bit in the CF flag,
        and clears the selected bit in the bit string to 0. The bit base
        operand can be a register or a memory location; the bit offset operand
        can be a register or an immediate value.
        If the bit base operand is a register, the instruction takes the modulo
        16, 32, or 64 of the bit offset operand (modulo size depends on the
        mode and register size). This allows any bit position to be selected.
</p>
<hr>
<h4>
        bts
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
        bts reg, reg
</li>
<li>
        bts reg, const
</li>
</ul>
<h5>Description</h5>

<p>
        Selects the bit in a bit string (specified with the first operand,
        called the bit base) at the bit-position designated by the bit offset
        operand (second operand), stores the value of the bit in the CF flag,
        and sets the selected bit in the bit string to 1. The bit base operand
        is a register; the bit offset operand can be a register or an immediate
        value.
        If the bit base operand is a register, the instruction takes the modulo
        16, 32, or 64 of the bit offset operand (modulo size depends on the
        mode and register size.) This allows any bit position to be selected.
</p>
<hr>
<h4>
        bsf
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
        bsf reg, reg
</li>
<li>
        bsf reg, mem
</li>
</ul>
<h5>Description</h5>

<p>
        Searches the source operand (second operand) for the least significant
        set bit (1 bit). If a least significant 1 bit is found, its bit index
        is stored in the destination operand (first operand). The source
        operand can be a register or memory location; the destination operand
        is a register. The bit index is an unsigned offset from bit 0 of the
        source operand. If the content of the source operand is 0, the content
        of the destination operand is undefined.
</p>
<hr>
<h4>
        bsr
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
        bsr reg, reg
</li>
<li>
        bsr reg, mem
</li>
</ul>
<h5>Description</h5>

<p>
        Searches the source operand (second operand) for the most significant
        set bit (1 bit). If a most significant 1 bit is found, its bit index is
        stored in the destination operand (first operand). The source operand
        can be a register or a memory location; the destination operand is a
        register. The bit index is an unsigned offset from bit 0 of the source
        operand. If the content source operand is 0, the content of the
        destination operand is undefined.
</p>
<hr>
<h4>
        bt
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
        bt reg, reg
</li>
<li>
        bt reg, const
</li>
</ul>
<h5>Description</h5>

<p>
        Selects the bit in a bit string (specified with the first operand,
        called the bit base) at the bit-position designated by the bit offset
        (specified by the second operand) and stores the value of the bit in
        the CF flag. The bit base operand is a register; the bit offset operand
        can be a register or an immediate value. The instruction takes the
        modulo 16, 32, or 64 of the bit offset operand (modulo size depends on
        the mode and register size).
</p>
<hr>
<h4>
        bt
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
        bt reg, reg
</li>
<li>
        bt reg, const
</li>
</ul>
<h5>Description</h5>

<p>
        Selects the bit in a bit string (specified with the first operand,
        called the bit base) at the bit-position desginated by the bit offset
        operand (second operand), stores the value of the bit in the CF flag,
        and complements the selected bit in the bit string. The bit base
        operand is a register; the bit offset operand can be a register or an
        immediate value. The instruction takes the modulo 16, 32, or 64 of the
        bit offset operand (modulo size depends on the mode and register size).
</p>
