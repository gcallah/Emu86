{% extends "ebase.html" %}
{% block content %}
    <div class="module">
        <details>
            <summary class="sum2">
            About Emu86
            </summary>

            <p>
            This is an open source project written by Gene Callahan, Abhishek
            Ramchandran, Varun Chopra, Nathan Conroy, Cindy Lee, and Nanda
            Kishore Kalidindi.  The goal is to create a simple learning tool to
            introduce students to assembly language programming in a class on,
            say, operating systems or compilers, where the focus is not
            assembly language, and actually using an assembler would be a
            distraction from the main theme of the course. It includes a
            (growing) subset of x86 assembler instructions. It currently 
            supports 2 x86 flavors: Intel and AT&amp;T assembly language. 
            <br />
            As of right now, we do not cover these AT&amp;T addressing modes: 
            (%ebx, %eax, 2) and var(, 1). If needed, please contact us. 
            </p>

            <details>
                <summary class="sum3">
                    x86 Assembly Guide
                </summary>
                <p>
                    Here is a page from the University of Virginia Computer
                    Science Department that gives a basic guide to Intel x86 
                    assembly language, which we have followed in creating 
                    our emulator:
                    <br />
                    <a
                    href="https://www.cs.virginia.edu/~evans/cs216/guides/x86.html">
                    Guide to Intel x86 assembly.
                    </a>
                    <br/> <br/>
                    In addition, here is a page from the Yale FLINT Group that 
                    gives a basic guide to AT&amp;T x86 assembly language. 
                    <br />
                    <a 
                    href="http://flint.cs.yale.edu/cs421/papers/x86-asm/asm.html">
                    Guide to AT&amp;T x86 assembly.
                    </a>
                </p>
            </details>
        </details>

        <details>
            <summary class="sum2">
            Sample Programs
            </summary>

            <p>
                Here are some sample programs written in our emulator, as
                illustrations of what can, at the moment, can be accomplished
                with it. (Of course, far lengthier programs are possible, but
                student exercises would typically be brief, like these
                samples.)
            </p>

            <details> 
                <summary class="sum3">
                    Intel Programs
                </summary>
            <ul class="nested">
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_Intel/array.asm">
                        Declare an array
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_Intel/power.asm">
                        Raise a number to a power
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_Intel/sum_test.asm">
                        Add two numbers
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_Intel/change_array_elem_test.asm">
                        Change array elements below min
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_Intel/key_test.asm">
                        Uses our keyboard interrupt
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_Intel/arithmetic_shift.asm">
                        Arithmetic shift
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_Intel/area.asm">
                        Calculate area of a rectangle
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_Intel/loop.asm">
                        A simple loop
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_Intel/mem_register_test.asm">
                        Store values into memory
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_Intel/log.asm">
                        Calculate log in base 2
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_Intel/array_average_test.asm">
                        Calculate average of an array of numbers
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_Intel/int_square_root.asm">
                        Calculate square root of a number
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_Intel/arithmetic_expression.asm">
                        Calculate an arithmetic expression
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_Intel/cel_to_fah.asm">
                        Convert from Celsius to Fahrenheit
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_Intel/data.asm">
                        How to use the .data section
                    </a>
                </li>
            </ul>
            </details>

            <details> 
                <summary class="sum3">
                    AT&amp;T Programs
                </summary>
            <ul class="nested">
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_ATT/array.asm">
                        Declare an array
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_ATT/power.asm">
                        Raise a number to a power
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_ATT/sum_test.asm">
                        Add two numbers
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_ATT/change_array_elem_test.asm">
                        Change array elements below min
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_ATT/key_test.asm">
                        Uses our keyboard interrupt
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_ATT/arithmetic_shift.asm">
                        Arithmetic shift
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_ATT/area.asm">
                        Calculate area of a rectangle
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_ATT/loop.asm">
                        A simple loop
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_ATT/mem_register_test.asm">
                        Store values into memory
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_ATT/log.asm">
                        Calculate log in base 2
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_ATT/array_average_test.asm">
                        Calculate average of an array of numbers
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_ATT/int_square_root.asm">
                        Calculate square root of a number
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_ATT/arithmetic_expression.asm">
                        Calculate an arithmetic expression
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_ATT/cel_to_fah.asm">
                        Convert from Celsius to Fahrenheit
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_ATT/data.asm">
                        How to use the .data section
                    </a>
                </li>
            </ul>
            </details>

            <details> 
                <summary class="sum3">
                    MIPS Assembler Programs
                </summary>
            <ul class="nested">
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_MIPS_ASM/array.asm">
                        Declare an array
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_MIPS_ASM/power.asm">
                        Raise a number to a power
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_MIPS_ASM/sum_test.asm">
                        Add two numbers
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_MIPS_ASM/change_array_elem_test.asm">
                        Change array elements below min
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_MIPS_ASM/arithmetic_shift.asm">
                        Arithmetic shift
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_MIPS_ASM/area.asm">
                        Calculate area of a rectangle
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_MIPS_ASM/loop.asm">
                        A simple loop
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_MIPS_ASM/log.asm">
                        Calculate log in base 2
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_MIPS_ASM/array_average_test.asm">
                        Calculate average of an array of numbers
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_MIPS_ASM/int_square_root.asm">
                        Calculate square root of a number
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_MIPS_ASM/arithmetic_expression.asm">
                        Calculate an arithmetic expression
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_MIPS_ASM/cel_to_fah.asm">
                        Convert from Celsius to Fahrenheit
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_MIPS_ASM/data.asm">
                        How to use the .data section
                    </a>
                </li>
            </ul>
            </details>

            <details> 
                <summary class="sum3">
                    MIPS Mnemonic Machine Language Programs
                </summary>
            <ul class="nested">
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_MIPS_MML/array.asm">
                        Declare an array
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_MIPS_MML/power.asm">
                        Raise a number to a power
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_MIPS_MML/sum_test.asm">
                        Add two numbers
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_MIPS_MML/change_array_elem_test.asm">
                        Change array elements below min
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_MIPS_MML/arithmetic_shift.asm">
                        Arithmetic shift
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_MIPS_MML/area.asm">
                        Calculate area of a rectangle
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_MIPS_MML/loop.asm">
                        A simple loop
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_MIPS_MML/log.asm">
                        Calculate log in base 2
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_MIPS_MML/array_average_test.asm">
                        Calculate average of an array of numbers
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_MIPS_MML/int_square_root.asm">
                        Calculate square root of a number
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_MIPS_MML/arithmetic_expression.asm">
                        Calculate an arithmetic expression
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_MIPS_MML/cel_to_fah.asm">
                        Convert from Celsius to Fahrenheit
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_MIPS_MML/data.asm">
                        How to use the .data section
                    </a>
                </li>
            </ul>
            </details>

            <details> 
                <summary class="sum3">
                    RISC-V Programs
                </summary>
            <ul class="nested">
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_RISCV/array.asm">
                        Declare an array
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_RISCV/power.asm">
                        Raise a number to a power
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_RISCV/sum_test.asm">
                        Add two numbers
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_RISCV/change_array_elem_test.asm">
                        Change array elements below min
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_RISCV/arithmetic_shift.asm">
                        Arithmetic shift
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_RISCV/area.asm">
                        Calculate area of a rectangle
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_RISCV/loop.asm">
                        A simple loop
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_RISCV/log.asm">
                        Calculate log in base 2
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_RISCV/array_average_test.asm">
                        Calculate average of an array of numbers
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_RISCV/int_square_root.asm">
                        Calculate square root of a number
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_RISCV/arithmetic_expression.asm">
                        Calculate an arithmetic expression
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_RISCV/cel_to_fah.asm">
                        Convert from Celsius to Fahrenheit
                    </a>
                </li>
                <li>
                    <a href ="https://github.com/gcallah/Emu86/blob/master/tests/tests_RISCV/data.asm">
                        How to use the .data section
                    </a>
                </li>
            </ul>
            </details>
        </details>

        <details>
            <summary class="sum2">
            The Data Section
            </summary>
        
            <p>
                This section is preceded by the directive ".data". <i>If</i>
                you have a data section, you must start the program section
                with the directive ".text". The data section allows the
                declaration of names for memory locations.
            </p>

<p>We attempted to read from templates/data.txt but failed.</p>
        </details>

        <details>
            <summary class="sum2">
            Instructions Available
            </summary>

            <p>
                Some of these are only partially done, i.e., some variant of
                an instruction may not work. We will do our best to note that
                where possible.
                <br>
                In the syntax descriptions, we have:
            </p>
            <ul class="nested">
                <li>
                con: constant
                </li>
                <li>
                lbl: label
                </li>
                <li>
                mem: memory location
                    <br>
                    A memory location may be designated by [num], where
                    <i>num</i> is the actual address, or by [reg], where
                    <i>reg</i> holds the memory address.
                </li>
                <li>
                reg: register
                </li>
            </ul>

            <details>
                <summary class="sum3">
                    Intel
                </summary>

                <details>
                    <summary class="sum4">
                    Interrupts
                    </summary>
<hr>
<h4>
             int
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            INT con
</li>
</ul>
<h5>Description</h5>

<p>
            The behavior of INT depends on both its "con" operand
            as well as the value of the EAX register. See the descriptions
            of specific interrupt commands below.
            We will build various "interrupt" handlers as needed.
            At present, we only have two:
                INT 22, with EAX set to 0, to get a key from
            the keyboard. And we only pretend the key is from the keyboard,
            since we are running on the Internet, and can't read the user's
            keyboard.
            And INT 32, to exit the program. There should be a 0 in EAX.
</p>
                </details>

                <details>
                    <summary class="sum4">
                    Data Movement
                    </summary>
<hr>
<h4>
             fld
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            fld con
</li>
</ul>
<h5>Description</h5>

<p>
            loads value onto stack
</p>
<hr>
<h4>
             fst
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            fst con
</li>
</ul>
<h5>Description</h5>

<p>
            stores value from top of stack
</p>
<hr>
<h4>
             mov
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            MOV reg, reg
</li>
<li>
            MOV reg, con
</li>
<li>
            MOV reg, mem
</li>
<li>
            MOV mem, reg
</li>
<li>
            MOV mem, mem
</li>
</ul>
<h5>Description</h5>

<p>
            Copies the value of op2 to the location mentioned in op1.
</p>
<hr>
<h4>
             pop
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            POP reg
</li>
<li>
            POP mem
</li>
</ul>
<h5>Description</h5>

<p>
            POPS the topmost value out of the stack.
            Decrements the stack pointer.
            Can move the stack value to a memory location or register.
</p>
<hr>
<h4>
             push
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            PUSH reg
</li>
<li>
            PUSH con
</li>
<li>
            PUSH mem
</li>
</ul>
<h5>Description</h5>

<p>
            PUSHES the value into the stack with reference to the stack
            pointer position (ESP). Increments the stack pointer automatically,
            everytime a PUSH is called. Callable to store a memory value,
            register value, and constant value to the stack.
</p>
<hr>
<h4>
             lea
</h4>

<h5>Syntax</h5>

<ul class="nested">
</ul>
<h5>Description</h5>

<p>
            Computes the effective address of the second operand (the source
            operand) and stores it in the first operand (destination operand).
            The source operand is a memory address (offset part) specified with
            one of the processors addressing modes; the destination operand is
            a register. The address-size and operand-size attributes affect the
            action performed by this instruction. The operand-size attribute of
            the instruction is determined by the chosen register; the
            address-size attribute is determined by the attribute of the code
            segment.
</p>
                </details>
                    
                <details>
                    <summary class="sum4">
                    Control Flow
                    </summary>
<hr>
<h4>
             cmp
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            CMP reg, reg
</li>
<li>
            CMP reg, mem
</li>
<li>
            CMP reg, con
</li>
</ul>
<h5>Description</h5>

<p>
            Compares op1 and op2, and sets (right now) the SF and ZF flags.
            It is not clear at this moment how to
            treat the OF and CF flags in Python,
            since Python integer arithmetic never carries or overflows!
</p>
<hr>
<h4>
             test
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            TEST reg, reg
</li>
<li>
            TEST reg, mem
</li>
<li>
            TEST reg, con
</li>
</ul>
<h5>Description</h5>

<p>
            Performs bitwise AND on op1 and op2 and sets the SF and ZF flags.
</p>
<hr>
<h4>
            jmp
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            JMP lbl
</li>
</ul>
<h5>Description</h5>

<p>
            Transfers program control to a different point in the instruction
            stream without recording return information. The destination
            (target) operand specifies the address of the instruction being
            jumped to. This operand can be an immediate value, a register, or
            a memory location.
</p>
<hr>
<h4>
             je
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            JE lbl
</li>
</ul>
<h5>Description</h5>

<p>
            Jumps if ZF is one. <br>
            Equivalent name: JZ
</p>
<hr>
<h4>
             jne
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            JNE lbl
</li>
</ul>
<h5>Description</h5>

<p>
            Jumps if ZF is zero. <br>
            Equivalent name: JNZ
</p>
<hr>
<h4>
             jg
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            JG lbl
</li>
</ul>
<h5>Description</h5>

<p>
            Jumps if SF == 0 and ZF == 0. <br>
            Equivalent name: JLNE
</p>
<hr>
<h4>
             jge
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            JGE lbl
</li>
</ul>
<h5>Description</h5>

<p>
            Jumps if SF == 0.
</p>
<hr>
<h4>
             jl
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            JL lbl
</li>
</ul>
<h5>Description</h5>

<p>
            Jumps if SF == 1. <br>
            Equivalent name: JGNE
</p>
<hr>
<h4>
             jle
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            JLE lbl
</li>
</ul>
<h5>Description</h5>

<p>
            Jumps if SF == 1 or ZF == 1.
</p>
<hr>
<h4>
             call
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            CALL lbl
</li>
</ul>
<h5>Description</h5>

<p>
            Pushes value of EIP to stack and jumps to the internal subroutine.
</p>
<hr>
<h4>
             ret
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            RET
</li>
</ul>
<h5>Description</h5>

<p>
            Pops value from stack to EIP and returns control to the
            the line after the subroutine call.
</p>
                </details>

                <details>
                    <summary class="sum4">
                    Arithmetic and Logic
                    </summary>
<hr>
<h4>
             add
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            ADD reg, reg
</li>
<li>
            ADD reg, mem
</li>
<li>
            ADD reg, con
</li>
</ul>
<h5>Description</h5>

<p>
            Adds the first operand with the second and stores the result in
            the first operand. The destination can be a register or memory
            location; the source can be an immediate, register, or memory
            location. Two memory operands cannot be used. Immediate values are
            sign extended. Works on both signed and unsigned integer operands.
</p>
<hr>
<h4>
             sub
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            SUB reg, reg
</li>
<li>
            SUB reg, mem
</li>
<li>
            SUB reg, con
</li>
</ul>
<h5>Description</h5>

<p>
            Subtracts the second operand from the first operand and stores the
            result in the first operand. The destination can be a register or
            memory location; the source can be an immediate, register, or
            memory location. Two memory operands cannot be used. Immediate
            values are sign extended. Evaluates the result for both signed
            and unsigned integer operands.
</p>
<hr>
<h4>
             imul
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            IMUL reg, reg
</li>
<li>
            IMUL reg, mem
</li>
<li>
            IMUL reg, con
</li>
</ul>
<h5>Description</h5>

<p>
            Performs a signed multiplication of two operands. The first
            operand is multiplied by the second operand. The destination is a
            general purpose register and the source can be an immediate, a
            register, or a memory location. The product is truncated and
            stored in the destination operand location.
</p>
<hr>
<h4>
             and
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            AND reg, reg
</li>
<li>
            AND reg, mem
</li>
<li>
            AND reg, con
</li>
</ul>
<h5>Description</h5>

<p>
            Performs a bitwise AND operation on the destination (first) and
            source (second) operands and stores the result in the destination
            operand location. The source operand can be an immediate, a
            register, or a memory location; the destination operand can be a
            register or memory location. Two memory operands cannot be used in
            one instruction. Each bit of the result is set to 1 if both
            corresponding bits of the first and second operands are 1;
            otherwise it is set to 0.
</p>
<hr>
<h4>
             or
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            OR reg, reg
</li>
<li>
            OR reg, mem
</li>
<li>
            OR reg, con
</li>
</ul>
<h5>Description</h5>

<p>
            Performs a bitwise inclusive OR operation between the destination
            (first) and source (second) operands and stores the result in the
            destination operand location. The source operand can be an
            immediate, a register, or a memory location; the destination
            operand can be a register or a memory location. Two memory
            operands cannot be used in one instruction. Each bit of the result
            of the OR instruction is set to 0 if both corresponding bits of
            the first and second operands are 0; otherwise, each bit is set to
            1.
</p>
<hr>
<h4>
             xor
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            XOR reg, reg
</li>
<li>
            XOR reg, mem
</li>
<li>
            XOR reg, con
</li>
</ul>
<h5>Description</h5>

<p>
            Performs a bitwise exlcusive OR (XOR) operation on the destination
            (first) and source (second) operands and stores the result in the
            destination operand location. The source operand can be an
            immediate, a register, or a memory location; the destination
            operand can be a register or a memory location. Two memory
            operands cannot be used in one instruction. Each bit of the result
            is 1 if the corresponding bits of the operands are different; each
            bit is 0 if the corresponding bits are the same.
</p>
<hr>
<h4>
             shl
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            SHL reg, reg
</li>
<li>
            SHL reg, mem
</li>
<li>
            SHL reg, con
</li>
</ul>
<h5>Description</h5>

<p>
            Shifts the bits in the first operand (destination operand) to the
            left by the number of bits specified in the second operand
            (count operand). Bits shifted beyonf the destination operand
            boundary are first shifted into the CF flag, then discarded. At the
            end of the shift operation, the CF flag contains the last bit
            shifted out of the destination operand.
            The destination operand can be a register or a memory location. The
            count operand can be an immediate value or the CL register.
</p>
<hr>
<h4>
             shr
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            SHR reg, reg
</li>
<li>
            SHR reg, mem
</li>
<li>
            SHR reg, con
</li>
</ul>
<h5>Description</h5>

<p>
            Shifts the bits in the first operand (destination operand) to the
            right by the number of bits specified in the second operand
            (count operand). Bits shifted beyond the destination operand
            boundary are first shifted into the CF flag, then discarded. At the
            end of the shift operation, the CF flag contains the last bit
            shifted out of the destination operand.
            The destination operand can be a register or a memory location. The
            count operand can be an immediate value or a register.
</p>
<hr>
<h4>
             not
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            NOT reg
</li>
</ul>
<h5>Description</h5>

<p>
            Performs a bitwise NOT operation (each 1 is set to 0, and each 0 is
            set to 1) on the destination operand and stores the result in the
            destination operand location. The destination operand is a
            register.
</p>
<hr>
<h4>
             inc
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            INC reg
</li>
</ul>
<h5>Description</h5>

<p>
            Adds 1 to the destination operand, while preserving the state of
            the CF flag. The destination operand must be a register. This
            instruction allows a loop counter to be updated without disturbing
            the CF flag. (Use an ADD instriction with an immediate operand of 1
            to perform an increment operation that does update the CF flag.)
</p>
<hr>
<h4>
             dec
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            DEC reg
</li>
</ul>
<h5>Description</h5>

<p>
            Subtracts 1 from the destination operand, while preserving the
            state of the CF flag. The destination operand must be a register.
            This instruction allows a loop counter to be updated without
            disturbing the CF flag. (To perform a decrement operation that
            updates the CF flag, use a SUB instruction with an immediate
            operand of 1.)
</p>
<hr>
<h4>
             neg
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            NEG reg
</li>
</ul>
<h5>Description</h5>

<p>
           Replaces the value of operand (the destination operand) with its
           two's complement. (This operation is equivalent to subracting the
           operand from 0.) The destination operand is located in a general-
           purpose register.
</p>
<hr>
<h4>
             idiv
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            IDIV reg
</li>
</ul>
<h5>Description</h5>

<p>
            The idiv instruction divides the contents of the 64 bit integer
            EDX:EAX (constructed by viewing EDX as the most significant four
            bytes and EAX as the least significant four bytes) by the specified
            operand value. The quotient result of the division is stored into
            EAX, while the remainder is placed in EDX.
</p>
<hr>
<h4>
        btr
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
        btr reg, reg
</li>
<li>
        btr reg, const
</li>
</ul>
<h5>Description</h5>

<p>
        Selects the bit in a bit string (specified with the first operand,
        called the bit base) at the bit-position designated by the bit offset
        operand (second operand), stores the value of the bit in the CF flag,
        and clears the selected bit in the bit string to 0. The bit base
        operand can be a register or a memory location; the bit offset operand
        can be a register or an immediate value.
        If the bit base operand is a register, the instruction takes the modulo
        16, 32, or 64 of the bit offset operand (modulo size depends on the
        mode and register size). This allows any bit position to be selected.
</p>
<hr>
<h4>
        bts
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
        bts reg, reg
</li>
<li>
        bts reg, const
</li>
</ul>
<h5>Description</h5>

<p>
        Selects the bit in a bit string (specified with the first operand,
        called the bit base) at the bit-position designated by the bit offset
        operand (second operand), stores the value of the bit in the CF flag,
        and sets the selected bit in the bit string to 1. The bit base operand
        is a register; the bit offset operand can be a register or an immediate
        value.
        If the bit base operand is a register, the instruction takes the modulo
        16, 32, or 64 of the bit offset operand (modulo size depends on the
        mode and register size.) This allows any bit position to be selected.
</p>
<hr>
<h4>
        bsf
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
        bsf reg, reg
</li>
<li>
        bsf reg, mem
</li>
</ul>
<h5>Description</h5>

<p>
        Searches the source operand (second operand) for the least significant
        set bit (1 bit). If a least significant 1 bit is found, its bit index
        is stored in the destination operand (first operand). The source
        operand can be a register or memory location; the destination operand
        is a register. The bit index is an unsigned offset from bit 0 of the
        source operand. If the content of the source operand is 0, the content
        of the destination operand is undefined.
</p>
<hr>
<h4>
        bsr
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
        bsr reg, reg
</li>
<li>
        bsr reg, mem
</li>
</ul>
<h5>Description</h5>

<p>
        Searches the source operand (second operand) for the most significant
        set bit (1 bit). If a most significant 1 bit is found, its bit index is
        stored in the destination operand (first operand). The source operand
        can be a register or a memory location; the destination operand is a
        register. The bit index is an unsigned offset from bit 0 of the source
        operand. If the content source operand is 0, the content of the
        destination operand is undefined.
</p>
<hr>
<h4>
        bt
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
        bt reg, reg
</li>
<li>
        bt reg, const
</li>
</ul>
<h5>Description</h5>

<p>
        Selects the bit in a bit string (specified with the first operand,
        called the bit base) at the bit-position designated by the bit offset
        (specified by the second operand) and stores the value of the bit in
        the CF flag. The bit base operand is a register; the bit offset operand
        can be a register or an immediate value. The instruction takes the
        modulo 16, 32, or 64 of the bit offset operand (modulo size depends on
        the mode and register size).
</p>
<hr>
<h4>
        bt
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
        bt reg, reg
</li>
<li>
        bt reg, const
</li>
</ul>
<h5>Description</h5>

<p>
        Selects the bit in a bit string (specified with the first operand,
        called the bit base) at the bit-position desginated by the bit offset
        operand (second operand), stores the value of the bit in the CF flag,
        and complements the selected bit in the bit string. The bit base
        operand is a register; the bit offset operand can be a register or an
        immediate value. The instruction takes the modulo 16, 32, or 64 of the
        bit offset operand (modulo size depends on the mode and register size).
</p>
                </details>
            </details>

            <details>
                <summary class="sum3">
                    MIPS
                </summary>

                <details>
                    <summary class="sum4">
                    Interrupts
                    </summary>
<hr>
<h4>
             SYSCALL
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            SYSCALL
</li>
</ul>
<h5>Description</h5>

<p>
            Exits program
</p>
                </details>

                <details>
                    <summary class="sum4">
                    Data Movement
                    </summary>
<hr>
<h4>
             LW
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            LW reg, reg
</li>
<li>
            LW reg, disp(reg)
</li>
</ul>
<h5>Description</h5>

<p>
            Copies the value of op2 to the location mentioned in op1.
</p>
<hr>
<h4>
             SW
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            SW reg, reg
</li>
<li>
            SW reg, disp(reg)
</li>
</ul>
<h5>Description</h5>

<p>
            Copies the value of op2 to the location mentioned in op1.
</p>
                </details>
                    
                <details>
                    <summary class="sum4">
                    Control Flow
                    </summary>
<hr>
<h4>
             slt
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            SLT reg, reg, reg
</li>
</ul>
<h5>Description</h5>

<p>
            Compares op2 and op3, and sets (right now) the SF and ZF flags.
            It is not clear at this moment how to
            treat the OF and CF flags in Python,
            since Python integer arithmetic never carries or overflows!
            Store the result of SF flag into op1
</p>
<hr>
<h4>
             slti
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            SLTI reg, con, reg
</li>
<li>
            SLTI reg, reg, con
</li>
</ul>
<h5>Description</h5>

<p>
            Compares op2 and op3, and sets (right now) the SF and ZF flags.
            It is not clear at this moment how to
            treat the OF and CF flags in Python,
            since Python integer arithmetic never carries or overflows!
            Store the result of SF flag into op1
</p>
<hr>
<h4>
            J
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            J lbl
</li>
<li>
            J loc
</li>
</ul>
<h5>Description</h5>

<p>
            Performs an unconditional jump to the specified address or label
            without storing anything.
</p>
<hr>
<h4>
            JAL
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            JAL loc
</li>
</ul>
<h5>Description</h5>

<p>
            Performs an uncondition jump to the specified address. Stores the
            current address in register $ra.
</p>
<hr>
<h4>
            Jr
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            Jr reg
</li>
</ul>
<h5>Description</h5>

<p>
            Jumps to the address held by register $ra.
</p>
<hr>
<h4>
             BEQ
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            BEQ reg, reg, con
</li>
</ul>
<h5>Description</h5>

<p>
            Jumps if registers are equal.
</p>
<hr>
<h4>
             BNE
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            BNE reg, reg, con
</li>
</ul>
<h5>Description</h5>

<p>
            Jumps if registers are not equal.
</p>
                </details>

                <details>
                    <summary class="sum4">
                    Arithmetic and Logic
                    </summary>
<hr>
<h4>
             ADD
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            ADD reg, reg, reg
</li>
</ul>
<h5>Description</h5>

<p>
            The 32 bit word value in Rt is added to the 32 bit word value in Rs
            to produce a 32 bit result. If the addition results in 32 bit 2's
            complement arithmetic overflow, the destination register is not
            modified and an Integer Overflow exception occurs. If the addition
            deos not overflow, the 32 bit result is placed into Rd.
</p>
<hr>
<h4>
             ADDI
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            ADDI reg, reg, con
</li>
</ul>
<h5>Description</h5>

<p>
            The 16 bit signed immediate is added to the 32 bit value in Rs to
            produce a 32 bit result. If the addition in 32 bit 2's complement
            arithmetic overflow, the destination register is not modified and
            an Integer Overflow exception occurs. If the addition does not
            overflow, the 32 bit result is placed into Rt.
</p>
<hr>
<h4>
             SUB
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            SUB reg, reg, reg
</li>
</ul>
<h5>Description</h5>

<p>
            The 32 bit word value in Rt is subtracted from the 32 bit value in
            Rs to produce a 32 bit result. If the subtraction results in a 32
            bit 2's complement arithmetic overflow, then the destination
            register is not modified and an Integer Overflow exception occurs.
            If it does not overflow, the 32 bit result is placed into Rd.
</p>
<hr>
<h4>
             MULT
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            MULT reg, reg
</li>
</ul>
<h5>Description</h5>

<p>
            The 32 bit word value in Rt is multiplied by the 32 bit value in Rs
            to produce a 64 bit result. The upper 32 bits of the 64 bit result
            is placed in the special register HI, whereas the lower 32 bits are
            placed in the register LO. Use MFHI and MFLO to move the result to
            a general purpose register.
</p>
<hr>
<h4>
             AND
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            AND reg, reg, reg
</li>
</ul>
<h5>Description</h5>

<p>
            Performs a bitwise AND operation on registers Rt and Rs and stores
            the result in register Rd. If the bit in both Rt and Rs is 1, Rd
            will get 1; otherwise it will get 0.
</p>
<hr>
<h4>
             AND
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            ANDI reg, reg, con
</li>
</ul>
<h5>Description</h5>

<p>
            Performs a bitwise AND operation on register Rs and a 16 bit sign-
            extended immediate extended to 32 bits and stores the result in
            register Rt. If the bit in both Rs and the immediate is 1, Rt gets
            a 1; otherwise it will get a 0.
</p>
<hr>
<h4>
             OR
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            OR reg, reg, reg
</li>
</ul>
<h5>Description</h5>

<p>
            Performs a bitwise OR operation on registers Rs and Rt and stores
            the result in register Rd. If the bit in both Rs and Rt is 0, Rd
            gets a 0; otherwise it will get a 1.
</p>
<hr>
<h4>
             OR
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            ORI reg, reg, con
</li>
</ul>
<h5>Description</h5>

<p>
            Performs a bitwise OR operation on register Rs and a 16 bit sign-
            extended immediate extended to 32 bits and stores the result in Rt.
            If the bit in both Rs and the immediate is 0, Rt gets a 0;
            otherwise it will get a 1.
</p>
<hr>
<h4>
             NOR
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            NOR reg, reg, reg
</li>
</ul>
<h5>Description</h5>

<p>
            Performs a bitwise NOR operation on registers Rs and Rt and stores
            the result in register Rd. If the bit in both Rs and Rt is 0, Rd
            gets a 1; otherwise it will get a 0.
</p>
<hr>
<h4>
             XOR
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            XOR reg, reg, reg
</li>
</ul>
<h5>Description</h5>

<p>
            Performs a bitwise XOR operation on registers Rs and Rt and stores
            the result in register Rd. If the bit in Rs and Rt is different, Rd
            gets a 1; otherwise it will get a 0.
</p>
<hr>
<h4>
             sll
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            SLL reg, reg, con
</li>
</ul>
<h5>Description</h5>

<p>
            The 32 bit word value in register Rs is shifted to the left by a
            number of bits specified by the 16 bit immediate. The result is
            stored as a 32 bit word value in register Rt. This is equivalent
            to multiplying by a power of 2. Bits shifted beyond the boundary of
            Rt are discarded.
</p>
<hr>
<h4>
             srl
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            SRL reg, reg, con
</li>
</ul>
<h5>Description</h5>

<p>
            The 32 bit word value in register Rs is shifted to the right by a
            number of bits specified by the 16 bit immediate. The result is
            stored as a 32 bit word value in register Rt. This is equivalent to
            dividing by a power of 2. Bits shifted beyond the boundary of Rt
            are discarded.
</p>
<hr>
<h4>
             DIV
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            DIV reg, reg
</li>
</ul>
<h5>Description</h5>

<p>
            The 32 bit word value in register Rs is divided by the 32 bit word
            value in register Rt. The 32 bit result of the division is stored
            in special register LO. The 32 bit modulus of the division is
            stored in the special register HI. Use MFHI and MFLO to move these
            results to general purpose registers.
</p>
<hr>
<h4>
             mfhi
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            MFHI reg
</li>
</ul>
<h5>Description</h5>

<p>
            Moves the value from the HI register into the
            destination register given.
</p>
<hr>
<h4>
             mflo
</h4>

<h5>Syntax</h5>

<ul class="nested">
<li>
            MFLO reg
</li>
</ul>
<h5>Description</h5>

<p>
            Moves the value from the LO register into the
            destination register given.
</p>
                </details>
            </details>
        </details>

        <details>
            <summary class="sum2">
            User Interface Features
            </summary>

            <p>
                Clicking on any register will display its value in binary.
            </p>
        </details>


    </div>
{% endblock content %}
